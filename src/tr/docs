# Dönüştürücüler

İşte her bir dönüştürücüyü detaylandıracağım yer. Bu, perde arkasında neler olduğunu anlamanıza ve bu tür dönüştürücülerin tersine mühendislik karşısında ne kadar etkili olduğuna dair bir fikir edinmenize yardımcı olacaktır.

Aşağıdaki konuları ele alacağız:
- Sayı Şifrelemesi
- String Şifrelemesi

## Sayı Şifrelemesi

Aşağıdaki senaryoyu varsayalım:
- $x$ istediğimiz şifrelemek istediğimiz sayıdır
- $n$, bloğun "seed"idir
- $d$, şifrelenmiş sayıdır

Basit xor mekaniklerine göre: $x\oplus n\oplus n=x$

Tanıma göre, eğer $n$ seed ise, çalışma zamanında $d$'yi $d = x\oplus n$ şeklinde hesaplamalıyız. Daha sonra, bytecode talimatını şu şekilde değiştirmeliyiz:

```java
int value = x;
```

şuna dönüşür;
```java
int value = d ^ n;
```

Burada, $d$ önceden hesaplanan bir sabit değer olarak ve $n$ ise opak bir yüklem (opaque predicate) olarak kullanılır. Örn:
```java
int value = 5;
```
şuna dönüşür;
```java
int predicate = 0x100;
int value = 105 ^ predicate;
```

## String Şifrelemesi

Dize şifrelemesi, işlenmeden önce üç temel koşula dayanır:
1. Dize sabiti, sabit havuzunda mevcut olmalıdır
2. Dize sabiti UTF-8 biçiminde biçimlendirilmelidir
3. String boş olmamalı

Bu şekilde, tipik decompiler/dissassemblers'dan dizeyi gizlemek için kodun içine simetrik bir şifreleme sistemini enjekte edebiliriz.

### Xor Algoritması

Şu anda, şifreli stringi hesaplamak için oldukça güçlü olan basit bir xor algoritması kullanıyoruz. Bu algoritma matematiksel olarak en düşük kalitede olsa ve muhtemelen polinomial zaman içinde veya lineer zaman içinde çözülebilecek olsa da, buradaki amacımız, bir opak yüklemin string şifrelemesini nasıl güçlendirebileceğine dair kolay ve bir konsept-örneği uygulaması sunmaktır. Skidfuscator'ün gelecekteki sürümlerinde, polimorfik bir yöntem kullanacağız.

Şu anda algoritma şu şekilde çalışmaktadır:

$f_y(x) = x \oplus y \oplus n$, bir karakterin bir String içinde şifrelenmesini ve şifrenin çözülmesini temsil eder, burada $n$ ve $m_ {max} $ değerleri 255 olarak verilmiştir

$y=i\mod m$

burada $i$, karakterin String içindeki dizinini temsil eder, $m$ rastgele "integerlerin" boyutunu temsil eder, $n$ tamsayı opak önermeyi temsil eder, $x$ ise String'in $i$ karakterini temsil eder.

Tanıma göre: $$ \begin{align} f_y(f_y(x))&=x\oplus y\oplus n\oplus y\oplus n\\
&=x\oplus y\oplus y\oplus n\oplus n\\ f_y(f_y(x))&=x \end{align} $$

Bu şekilde, yerel olarak depolanan bir dizi integer anahtarı ve bir opak yüklem ile güçlendirilen kullanılabilir bir şifreleme/çözme algoritması elde ediyoruz. Uygulamanın örneğine [buradan](https://github.com/terminalsin/skidfuscator-java-obfuscator/blob/master/dev.skidfuscator.obfuscator/obfuscator/src/main/java/dev/skidfuscator/obfuscator/transform/impl/string/BasicEncryptionGenerator.java) ulaşabilirsiniz

Dışarı çıkarma (outlining), bir yöntemden kodu çıkartarak ayrı, bağımsız bir yönteme (method) yerleştirme işlemini yapar. Bu sıklıkla kodun okunabilirliğini ve geliştirilebilmesini artırmak için yapılır, çünkü bu yöntem methodun ne yaptığını görmek için methodu daha küçük, daha odaklanmış parçalara bölerek methodun yaptığını anlamayı kolaylaştırabilir. Bu sayede kod daha anlaşılabilir bir hale gelir.

Dışarı çıkarma (outlining), kodun genel akışını, yapısını anlamayı ve tersine mühendislik yapmayı daha zor hale getirebilir, bu nedenle dışarı çıkarma, kod şifrelemesi olarak da kullanılabilir. Kodu daha küçük parçalara bölmek ve farklı yöntemlere (method) ayırmak, kodu inceleyen birinin farklı akış parçaları(parts of flow) arasındaki ilişkileri anlamasını ve bu parçaların bir araya gelerek belirli bir işlevi nasıl gerçekleştirdiğini anlamasını daha zor bir hale getirebilir. Bu şekilde, kodun anlaşılmasını zorlaştırarak daha güçlü bir koruma sağlayabilir.

![Outlining graph explanation](https://i.imgur.com/2HMq0a4.png)

Dışarı çıkarma ile ilgili harika şey: *teknik olarak* geri döndürülemez olmasıdır! İyi bir dışarı çıkarmayı (outlining) şifrelemenin orijinal durumuna döndürebilmek için bir deobfuscator, *yöntem gömme (inlining)* yapmak zorundadır, ki bu sonucun her zaman orijinal kaynak koduyla aynı olucağını *garantilemez*. Ayrıca, bu şifreleme çözücünün(deobfuscator) değişkenlerle(integer) ve diğer çeşitli hassas bytecode manipülasyonlarıyla uğraşması gerektiğinden, hepsi hesaplama hatalarına sebep olabilir.

Yani dışarı çıkarma(outlining) şifrelemeyi genel olarak oldukça etkilleyen ve kullanışlı yapan bir yöntemdir :)
